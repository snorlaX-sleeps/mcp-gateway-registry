# Global configuration - these values are passed to all subcharts
global:
  # When installing chart from repository, add --set global.chartVersion=$(git rev-parse HEAD) to add the git hash to a configmap for debugging
  chartVersion:

  # Domain configuration - update this to your actual domain
  domain: "DOMAIN"

  # Security settings
  # secretKey: If not provided, a random 64-character key is auto-generated
  # and shared between auth-server and registry via a shared secret.
  # The generated key persists across helm upgrades.
  # Uncomment and set to use a specific key:
  # secretKey: "your-secure-key-here"

  # Shared secret name - automatically set for stack deployment
  # Both auth-server and registry will use this secret for SECRET_KEY and federation (if enabled)
  sharedSecretName: "shared-secret"

  # Federation configuration - shared between registry and auth-server
  federation:
    staticTokenAuthEnabled: false # If not provided, defaults to false
    staticToken: # If not provided, a random token is auto-generated
    encryptionKey: # If not provided, a Fernet key is auto-generated
    registryId: # Unique identifier for this registry instance (optional)

  # Authentication Provider Configuration
  # Choose ONE provider: keycloak or entra
  authProvider:
    # Provider type: "keycloak" or "entra"
    type: keycloak
    keycloak:
      adminUsername: &keycloakAdmin "user"
      realm: &keycloakRealm "mcp-gateway"
      # Don't set password here - let Keycloak chart generate it
    entra:
      adminGroupId: # UUID of Entra admin group

  # Common ingress settings
  ingress:
    inboundCidrs: # optional comma separated list of allowed inbound CIDR ranges
    className: alb
    tls: true
    # Routing mode: "subdomain" or "path"
    # - subdomain: auth-server.domain.com, mcpregistry.domain.com, keycloak.domain.com
    # - path: domain.com/auth-server, domain.com/registry, domain.com/keycloak
    routingMode: subdomain
    # Path configuration (only used when routingMode: path)
    paths:
      authServer: /auth-server
      registry: /registry
      keycloak: /keycloak # make sure to update keycloak.httpRelativePath (/keycloak/)

mongodb-kubernetes:
  operator:
    enableClusterMongoDBRoles: false
    telemetry:
      installClusterRole: false
    nodeSelector: {}

# MongoDB configuration
mongodb:
  enabled: true
  user: my-user # username for MongDB
  password: CHANGEME # Set the password for the MongoDB user

# Keycloak configuration
# Set create: true to deploy Keycloak as part of this stack
# Set create: false to use an external Keycloak instance
# NOTE: When using Entra (global.authProvider.type: entra), set create: false
keycloak:
  create: true  # Deploy Keycloak in this stack (set to false for external Keycloak or Entra)
  image:
    registry: public.ecr.aws

  global:
    security:
      allowInsecureImages: true

  auth:
    adminUser: *keycloakAdmin
    # Don't set adminPassword - let it auto-generate

  postgresql:
    image:
      registry: public.ecr.aws

  # HTTP relative path for path-based routing
  # IMPORTANT: This must match global.ingress.paths.keycloak when routingMode is "path"
  # For subdomain routing, set to "/"
  # IMPORTANT: This must have a trailing "/"
  httpRelativePath: /

  extraEnvVars:
    - name: KC_PROXY
      value: edge
    - name: KC_PROXY_HEADERS
      value: xforwarded

  ingress:
    enabled: false  # We use a custom ingress template that supports global.domain

  nodeSelector: {}

  # Lifecycle hook to configure realm SSL settings
  lifecycleHooks:
    postStart:
      exec:
        command:
          - "/bin/bash"
          - "-c"
          - |
            (
              echo "PostStart: Waiting for Keycloak to be ready..."
              # Determine the base path - check if KC_HTTP_RELATIVE_PATH is set
              BASE_PATH="${KC_HTTP_RELATIVE_PATH:-}"
              BASE_URL="http://localhost:8080${BASE_PATH}"
              echo "Using base URL: $BASE_URL"
              for i in {1..120}; do
                if curl -sf ${BASE_URL}/realms/$KC_SPI_ADMIN_REALM > /dev/null 2>&1; then
                  echo "Keycloak ready after $i attempts"
                  break
                fi
                sleep 5
              done
              sleep 10
              echo "Configuring $KC_SPI_ADMIN_REALM realm..."
              /opt/bitnami/keycloak/bin/kcadm.sh config credentials \
                --config /tmp/kcadm.config \
                --server ${BASE_URL} \
                --realm $KC_SPI_ADMIN_REALM \
                --user $KC_BOOTSTRAP_ADMIN_USERNAME \
                --password $(cat $KC_BOOTSTRAP_ADMIN_PASSWORD_FILE)
              /opt/bitnami/keycloak/bin/kcadm.sh update \
                --config /tmp/kcadm.config \
                realms/$KC_SPI_ADMIN_REALM \
                -s sslRequired=NONE
              echo "âœ“ $KC_SPI_ADMIN_REALM realm configured!"
            ) > /tmp/poststart-config.log 2>&1 &

# Keycloak configuration job
# Automatically enabled when global.authProvider.type = "keycloak"
# Set to false to skip configuration (e.g., when using pre-configured Keycloak)
# NOTE: When using Entra (global.authProvider.type: entra), set enabled: false
keycloak-configure:
  enabled: true  # Set to false to skip Keycloak configuration or when using Entra
  keycloak:
    realm: *keycloakRealm
    adminUser: *keycloakAdmin
  # authServer.externalUrl will be templated in the subchart using global.domain

# Keycloak ingress for mcp-gateway-registry
# Whether to create an ingress for Keycloak with this Chart (only applicable when keycloak.create: true)
keycloakIngress:
  enabled: true

# Mongodb configuration job
mongodb-configure:
  enabled: true # Whether to run the MongoDB configuration job

# Registry service configuration
registry:
  app:
    replicas: 2 # set to > 1 replica for high availability
    # Deployment mode: with-gateway (nginx integration) or registry-only (catalog only)
    deploymentMode: with-gateway

    # Registry mode: full, skills-only, mcp-servers-only, agents-only
    registryMode: full
  ingress:
    enabled: true
    ingressClassName: alb

  nodeSelector: {}

# Auth server configuration
auth-server:
  app:
    replicas: 2 # set to > 1 replica for high availability

  keycloak:
    enabled: true
    realm: *keycloakRealm
    # externalUrl will be templated in the subchart using global.domain

  # Entra ID settings (used when global.authProvider.type = "entra")
  entra:
    clientId: ""
    clientSecret: ""
    tenantId: ""

  ingress:
    enabled: true
    ingressClassName: alb

  nodeSelector: {}
